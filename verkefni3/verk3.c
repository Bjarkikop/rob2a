#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, dgtl2,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  touchSensor,    sensorTouch)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Motor,  port6,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           arMMotor,      tmotorNormal, openLoop)
#pragma config(Motor,  port3,           armMotor,      tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
This program makes the Robot drive in an maze pattern but,
you can stop it and remote control the motors and claw.

----------------------------------------------------------------------------------------------------*/
// Turn formula == (40/10.5) *360 == 1371/4 == 342.75
// Formula fyrir BASEDIST 50/10*3.14) * 360
// 3.81
#define TURN 3.1
#define BASEDIST 286.5

void reset_encode(){
	SensorValue[rightEncoder]=0;
	SensorValue[leftEncoder]=0;
};

void stop_motor(int stop_time){
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	wait1Msec(stop_time);
};

void robot_turn(bool l_r,int deg){
	if(l_r){
		while(TURN *deg > abs(SensorValue[rightEncoder])){
			motor[leftMotor] = -80;
			motor[rightMotor] = 80;
		}
	}
	else{
		while(TURN *deg > abs(SensorValue[leftEncoder])){
			motor[leftMotor] = 80;
			motor[rightMotor] = -80;
		}
	}
};

void drive() {
	while(BASEDIST>abs(SensorValue[rightEncoder])){
		if(abs(SensorValue[rightEncoder]) == abs(SensorValue[leftEncoder])) // If rightEncoder has counted the same amount as leftEncoder:
		{
			// Move Forward
			motor[rightMotor] = 80;		    // Right Motor is run at power level 80
			motor[leftMotor]  = 80;		    // Left Motor is run at power level 80

		}
		else if(abs(SensorValue[rightEncoder]) > abs(SensorValue[leftEncoder]))	// If rightEncoder has counted more encoder counts
		{
			// Turn slightly right
			motor[rightMotor] = 70;		    // Right Motor is run at power level 60
			motor[leftMotor]  = 80;

		}
		else	// Only runs if leftEncoder has counted more encoder counts
		{
			// Turn slightly left
			motor[rightMotor] = 80;		    // Right Motor is run at power level 80
			motor[leftMotor]  = 70;

		}
	}
}
bool turn_array[14]= {0,1,1,0,0,1,1,0,0,1,1,0,1,1};
task one(){

		int i = 0;
		while(i< 14){
			reset_encode();
			drive();
			reset_encode();
			stop_motor(500);
			robot_turn(turn_array[i], 90);
			i++;
		}
}

task two(){
	while(1==1){
			motor[leftMotor]  = vexRT[Ch3];   // Left Joystick Y value
    	motor[rightMotor] = vexRT[Ch2];   // Right Joystick Y value
		 if(vexRT[Btn6U] == 1)
	    {
	      motor[arMMotor] = 40;
	    }
	    else if(vexRT[Btn6D] == 1)
	    {
	      motor[arMMotor] = -40;
	    }
	    else
	    {
	      motor[arMMotor] = 0;
	    }
	    if(vexRT[Btn8R] == 1)
	    {
	      motor[armMotor] = 40;
	    }
	    else if(vexRT[Btn8L] == 1)
	    {
	      motor[armMotor] = -40;
	    }
	    else
	    {
	      motor[armMotor] = 0;
	    }
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
	StartTask(one);
	while (1==1){

	};
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
